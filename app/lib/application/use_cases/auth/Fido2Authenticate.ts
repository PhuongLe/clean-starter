import { generateLoginChallenge, generateRegistrationChallenge, parseLoginRequest, parseRegisterRequest, verifyAuthenticatorAssertion } from "@webauthn/server";
import { isEmpty } from "lodash";
import { isNullOrUndefined } from "util";
import { ForbiddenProblem, MissingRequiredInputsProblem, Problem, UnauthorizedProblem } from "../../../domain/entities/Problem";
import IAuthnConfig from "../../../interfaces/security/IAuthnConfig";
import { IUserRepository } from "../../repositories/IUserRepository";

/**
 * Passwordless authentication with FIDO2 standard 
 */
export default class Fido2Authenticate {
  private readonly userRepository: IUserRepository
  private readonly authnConfig: IAuthnConfig

  constructor(
    userRepository: IUserRepository,
    authnConfig: IAuthnConfig
  ) {
    this.userRepository = userRepository,
      this.authnConfig = authnConfig
  }

  /** 
   * Generate attestation options to challenge register request with passwordless authentication
  */
  public async generateAttestationOptions(email: string): Promise<object | Problem> {
    // tslint:disable-next-line: possible-timing-attack
    if (isEmpty(email)) {
      return new MissingRequiredInputsProblem({
        detail: "missing username."
      })
    }

    if (this.authnConfig.enablePasswordless == false) {
      return new ForbiddenProblem({
        detail: "Passwordless authentication is not enabled."
      })
    }

    const attestationChallengeResponse = generateRegistrationChallenge({
      relyingParty: { name: 'willbe.vn', id: "localhost" },
      user: { id: "webauthn_uuid", name: email }
    });

    const user = await this.userRepository.create(email, attestationChallengeResponse.challenge)
    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid credential'
      })
    }
    return attestationChallengeResponse
  }

  /**
   * Verify attestation sent from browser to register new login
   * @param attestation: user credential generated by hardware security key
   * @returns: return true if the verification succeeded. Otherwise, return false
   */
  public async validateAttestation(attestation: any): Promise<object | Problem> {
    const { key, challenge } = parseRegisterRequest(attestation);

    if (isNullOrUndefined(challenge)) {
      return new UnauthorizedProblem({
        detail: 'Invalid register request'
      })
    }

    const user = this.userRepository.loadByChallenge(challenge);

    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid register request'
      })
    }

    this.userRepository.addKeyToUser(user, key);

    return { loggedIn: true };
  }

  /**
   * Generate assertion options to challenge login request with passwordless authentication
   * @param email: email of logging user
   * @returns: assertion option challenge
   */
  public async generateAssertionOptions(email: string): Promise<object | Problem> {
    // tslint:disable-next-line: possible-timing-attack
    if (isEmpty(email)) {
      return new MissingRequiredInputsProblem
    }

    const user = await this.userRepository.loadByEmail(email)
    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid credential'
      })
    }

    const assertionChallenge = generateLoginChallenge(user.key);

    this.userRepository.updateUserChallenge(user, assertionChallenge.challenge);

    return assertionChallenge;
  }

  /**
    * Verify assertion sent from browser for login request
    * @param credentials: user credential generated by hardware security key
    * @returns: return true if the verification succeeded. Otherwise, return false
    */
  public async validateAssertion(credentials: any): Promise<object | Problem> {
    const { challenge, keyId } = parseLoginRequest(credentials);

    if (isNullOrUndefined(challenge)) {
      return new UnauthorizedProblem({
        detail: 'Invalid challenge'
      })
    }

    const user = this.userRepository.loadByChallenge(challenge);

    if (isNullOrUndefined(user) || isNullOrUndefined((await user).key) || ((await user).key.credID !== keyId)) {
      return new UnauthorizedProblem({
        detail: 'Invalid login challenge request'
      })
    }

    const result = verifyAuthenticatorAssertion(credentials, (await user).key);

    return { loggedIn: result }
  }
}