import { isEmpty } from "lodash";
import { isNullOrUndefined } from "util";
import { MissingRequiredInputsProblem, Problem, UnauthorizedProblem } from "../../../domain/entities/Problem";
import { IUserRepository } from "../../repositories/IUserRepository";
import { generateLoginChallenge, generateRegistrationChallenge, parseLoginRequest, parseRegisterRequest, verifyAuthenticatorAssertion } from "./../webauthn";
/**
 * Passwordless authentication with FIDO2 standard 
 */
export default class Fido2Authenticate {
  private readonly userRepository: IUserRepository

  constructor(
    userRepository: IUserRepository
  ) {
    this.userRepository = userRepository
  }

  /** 
   * Generate attestation options for passwordless authentication request
  */
  public async requestRegister(email: string): Promise<object | Problem> {
    // tslint:disable-next-line: possible-timing-attack
    if (isEmpty(email)) {
      return new MissingRequiredInputsProblem
    }
    const challengeResponse = generateRegistrationChallenge({
      relyingParty: { name: 'willbe.vn' },
      user: { id: "webauthn_uuid", name: email }
    });

    const user = await this.userRepository.create(email, challengeResponse.challenge)
    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid credential'
      })
    }
    return challengeResponse
  }

  /**
   * Verify attestation sent from browser and register new login
   * @param attestation: user credential generated by hardware security key
   * @returns: return true if the verification succeeded. Otherwise, return false
   */
  public async register(attestation: any): Promise<object | Problem> {
    const { key, challenge } = parseRegisterRequest(attestation);

    if (isNullOrUndefined(challenge)) {
      return new UnauthorizedProblem({
        detail: 'Invalid register request111'
      })
    }

    const user = this.userRepository.loadByChallenge(challenge);

    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid register request'
      })
    }

    this.userRepository.addKeyToUser(user, key);

    return { loggedIn: true };
  }

  /**
   * Generate assertion options for login request
   * @param email: email of logging user
   * @returns: assertion option challenge
   */
  public async login(email: string): Promise<object | Problem> {
    // tslint:disable-next-line: possible-timing-attack
    if (isEmpty(email)) {
      return new MissingRequiredInputsProblem
    }

    const user = await this.userRepository.loadByEmail(email)
    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid credential'
      })
    }

    const assertionChallenge = generateLoginChallenge(user.key);

    this.userRepository.updateUserChallenge(user, assertionChallenge.challenge);

    return assertionChallenge;
  }

  /**
    * Verify assertion sent from browser for login request
    * @param credentials: user credential generated by hardware security key
    * @returns: return true if the verification succeeded. Otherwise, return false
    */
  public async loginChallenge(credentials: any): Promise<object | Problem> {
    const { challenge, keyId } = parseLoginRequest(credentials);

    if (isNullOrUndefined(challenge)) {
      return new UnauthorizedProblem({
        detail: 'Invalid challenge'
      })
    }

    const user = this.userRepository.loadByChallenge(challenge);

    if (isNullOrUndefined(user) || isNullOrUndefined((await user).key) || ((await user).key.credID !== keyId)) {
      return new UnauthorizedProblem({
        detail: 'Invalid login challenge request'
      })
    }

    const result = verifyAuthenticatorAssertion(credentials, (await user).key);

    return { loggedIn: result }
  }
}