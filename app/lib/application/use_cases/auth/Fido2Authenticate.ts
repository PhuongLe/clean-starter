import { generateLoginChallenge, generateRegistrationChallenge, parseLoginRequest, parseRegisterRequest, verifyAuthenticatorAssertion } from "@webauthn/server";
import { isEmpty } from "lodash";
import { isNullOrUndefined } from "util";
import { ForbiddenProblem, MissingRequiredInputsProblem, Problem, UnauthorizedProblem, BadRequestProblem } from "../../../domain/entities/Problem";
import IAuthnConfig from "../../../interfaces/security/IAuthnConfig";
import { IUserRepository } from "../../repositories/IUserRepository";
import { IJwtProvider } from "../../security/IJwtProvider";
import { User } from "../../../domain/entities/User";

/**
 * Passwordless authentication with FIDO2 standard 
 */
export default class Fido2Authenticate {
  private readonly userRepository: IUserRepository
  private readonly authnConfig: IAuthnConfig
  private readonly jwtProvider: IJwtProvider

  constructor(
    userRepository: IUserRepository,
    authnConfig: IAuthnConfig,
    jwtProvider: IJwtProvider
  ) {
      this.userRepository = userRepository,
      this.authnConfig = authnConfig,
      this.jwtProvider = jwtProvider
  }

  /** 
   * Generate attestation options to challenge register request with passwordless authentication
  */
  public async generateAttestationOptions(email: string, passwordless: boolean): Promise<object | Problem> {
    if (passwordless && this.authnConfig.enablePasswordless == false) {
      return new ForbiddenProblem({
        detail: "Passwordless authentication is not enabled."
      })
    }

    if (!passwordless && this.authnConfig.enable2FAWithFido2 == false) {
      return new ForbiddenProblem({
        detail: "Second authentication with FIDO 2 is not enabled."
      })
    }
    
    // tslint:disable-next-line: possible-timing-attack
    if (isEmpty(email)) {
      return new MissingRequiredInputsProblem({
        detail: "missing username."
      })
    }

    const attestationChallengeResponse = generateRegistrationChallenge({
      relyingParty: { name: 'clean-starter', id: "localhost" },
      user: { id: "webauthn_uuid", name: email }
    });

    let user = await this.userRepository.loadByEmail(email);

    if (passwordless){
      if (isNullOrUndefined(user)){
        user = await this.userRepository.create(email, attestationChallengeResponse.challenge)
      }
    }
  
    this.userRepository.updateUserChallenge(user, attestationChallengeResponse.challenge);

    return attestationChallengeResponse
  }

  /**
   * Verify attestation sent from browser to register new login
   * @param attestation: user credential generated by hardware security key
   * @returns: return true if the verification succeeded. Otherwise, return false
   */
  public async validateAttestation(attestation: any): Promise<object | Problem> {
    if (this.authnConfig.enablePasswordless == false) {
      return new ForbiddenProblem({
        detail: "Passwordless authentication is not enabled."
      })
    }

    const { key, challenge } = parseRegisterRequest(attestation);

    if (isNullOrUndefined(challenge)) {
      return new UnauthorizedProblem({
        detail: 'Invalid register request'
      })
    }

    const user = await this.userRepository.loadByChallenge(challenge);

    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid register request'
      })
    }

    console.log("TESTING ... passwordless , user.key = " + user.key);
    if (!isNullOrUndefined(user.key)){
      console.log("TESTING ... user.key.publicKey = " + user.key.publicKey);
      console.log("TESTING ... key.publicKey = " + key.publicKey);
    }

    if (!isNullOrUndefined(user.key) && (user.key.credID === key.credID)){
      return new BadRequestProblem({
        detail: 'Duplicated security device key registration'
      })
    }

    this.userRepository.addKeyToUser(user, key);

    return { registerStatus: true };
  }

  /**
   * Generate assertion options to challenge login request with passwordless authentication
   * @param email: email of logging user
   * @returns: assertion option challenge
   */
  public async generateAssertionOptions(email: string): Promise<object | Problem> {
    if (this.authnConfig.enablePasswordless == false) {
      return new ForbiddenProblem({
        detail: "Passwordless authentication is not enabled."
      })
    }

    // tslint:disable-next-line: possible-timing-attack
    if (isEmpty(email)) {
      return new MissingRequiredInputsProblem
    }

    const user = await this.userRepository.loadByEmail(email)
    if (isNullOrUndefined(user)) {
      return new UnauthorizedProblem({
        detail: 'Invalid credentials'
      })
    }

    const assertionChallenge = generateLoginChallenge(user.key);

    this.userRepository.updateUserChallenge(user, assertionChallenge.challenge);

    return assertionChallenge;
  }

  /**
    * Verify assertion sent from browser for login request
    * @param credentials: user credential generated by hardware security key
    * @returns: return true if the verification succeeded. Otherwise, return false
    */
  public async validateAssertion(credentials: any): Promise<object | Problem> {
    if (this.authnConfig.enablePasswordless == false) {
      return new ForbiddenProblem({
        detail: "Passwordless authentication is not enabled."
      })
    }

    const { challenge, keyId } = parseLoginRequest(credentials);

    if (isNullOrUndefined(challenge)) {
      return new UnauthorizedProblem({
        detail: 'Invalid challenge'
      })
    }

    const user = await this.userRepository.loadByChallenge(challenge);

    if (isNullOrUndefined(user) || isNullOrUndefined(user.key) || (user.key.credID !== keyId)) {
      return new UnauthorizedProblem({
        detail: 'Invalid login challenge request'
      })
    }

    const result = verifyAuthenticatorAssertion(credentials, user.key);
    this.userRepository.updateUserChallenge(user, "");

    return {token: this.jwtProvider.generateToken({
                          id: user.id
                        }),
            status: true}
  }
}